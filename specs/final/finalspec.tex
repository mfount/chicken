\documentclass{article}
\usepackage{chicken}

\DateAndTitle{17 April 2015}{Final Specification}

\usepackage{xcolor}
\newcommand{\todo}[1]{\textcolor{red}{\textbf{\textsf{[#1]}}}}

\begin{document}


%\section{Names and Emails}
%\begin{itemize}
%  \item Aleksandar Makelov --- \texttt{amakelov@college.harvard.edu}
%  \item Ben Wetherfield --- \texttt{bwetherfield@college.harvard.edu}
%  \item Chan Kang --- \texttt{chankang@college.harvard.edu}
%  \item Michael Fountaine --- \texttt{mfount@college.harvard.edu}
%\end{itemize}


\section{Overview}
\begin{description}
  \item[\textbf{Problem:}]
    Using Coq, verify Timsort, python's preferred sorting algorithm!
    \todo{Improve motivation? Possibly include discussion of failures of
    implementations of Timsort in languages other than Python 3.x.}
    Timsort is a hybrid of insertion sort and mergesort, plus some heuristics
    about memory management and other optimizations.
    Our simplified version will include a reduced version of these
    heuristics.

  \item[\textbf{Solution sketch:}]
    We will take an incremental approach (and all of our algorithms
    will be functional, using persistent data structures).
    We're going to start with a
    simplified version of Timsort,
    hybridizing mergesort and insertion sort
    with a small subset of the heuristics used by Timsort in full.
    At first, all of these components of this simplified Timsort will
    be independently verified; the combined algorithm implementation
    will be thoroughly unit-tested.
    For short, call this algorithm Simsort.
    Implementing Simsort will be the conclusion of our core functionality.

    Next, we will implement heaps and a verified heapsort;
    by replacing insertion sort with heapsort in Simsort,
    we should get a constant-factor time improvement.
    Then, our primary goal beyond core functionality will
    be verification of Simsort.
    From there, we will implement extra extensions, as discussed below,
    possibly adding more heuristics to Simsort, approaching verification
    of Timsort in full.

  \item[\textbf{Goals:}]
    Primarily, we'd like to verify Timsort (i.e., Simsort) as a way to
    learn more about Coq and certified programming.

\end{description}


\section{Prioritized Feature List}
\emph{Note:} All algorithms and data structures used in this project will
be functional; in particular, we'll use persistent data structures.

\paragraph{Core Features}
\begin{itemize}
  \item \textbf{Fundamentals.}
    Booleans, natural numbers (defined inductively), polymorphic lists,
    stacks (for very basic representations of memory needed within Timsort
    heuristics).
  \item \textbf{Verified insertion sort.}
    Verified insertion sort of lists of natural numbers.
  \item \textbf{Verified merge sort.}
    Verified merge sort of lists of natural numbers.
  \item \textbf{Simsort.}
    Fully tested implementation of Simsort (our hybridization of verified
    merge sort, verified insertion sort, and a modified subset of the
    heuristics used in Timsort).
    \todo{talk about what the heuristics might be}

\end{itemize}

\paragraph{Cool Extensions}
\begin{itemize}
  \item \textbf{Heaps.}
    Polymorphic priority queues.
    If it provides an advantage in asymptotics,
    we will use heaps to re-implement stacks.
  \item \textbf{Heap Sort.}
    Verified heap sort of heaps of natural numbers.
    This will operate on lists of natural numbers, represented perhaps
    as trees or priority queues.
  \item \textbf{Augmenting Simsort with heapsort.}
    Fully tested implementation of Simsort, with heapsort replacing
    insertion sort, for a slight improvement in asymptotics.
  \item \textbf{Verified Simsort.}
    This is our main goal beyond core functionality.
    We will improve the fully tested Simsort to
    a rigorously verified Simsort (using Coq).
  \item \textbf{Passing foreign tests.}
    We have come across a few known to be broken implementations of Timsort
    in certain languages (e.g., Java's clone of Timsort,
    early versions of Python 2.x's Timsort).
    For this cool extension, we would take some of the failing test cases for
    those other implementations, adapt them to use the same heuristic
    assumptions that we've used with Simsort, and show that our verified
    Simsort passes those tests.
  \item \textbf{Adding more heuristics.}
    If we make it this far, we will add more heuristics to Simsort,
    showing that each addition passes verification and doesn't break
    invariants, working our way gradually to a verified, functional
    Timsort in full.
\end{itemize}


\section{Technical Specification}
\subsection{Interfaces.} References to code written thus far are included
throughout this section. \verb|chicken| is the root directory of our github
repository, located at \verb|https://github.com/mfount/chicken|.

Also, all libraries originating from SF \cite{sf} (which we've populated
with exercise solutions), will eventually be refactored into neater,
application-specific libraries once we have a clearer picture of how
we will refactor code to optimize proofs.

\paragraph{Data Structures, related methods, and proofs of them.}

\begin{itemize}
  \item \textbf{Booleans.}
Our code for bools so far is contained in \verb`chicken/coq/Basics.v`,
a library provided with SF \cite{sf}, which we have filled out with solutions
to the relevant exercises.
This includes axioms and definitions pertaining to bools
(e.g. \verb+not false = true+), proofs of simple lemmas (primarily done
using the \verb+destruct+ tactic to prove by case exhaustion)
familiar binary operations, and proofs of them.

  \item \textbf{Natural numbers.}
    There is code for nats in \verb|chicken/coq/Basics.v| and
    \verb|chicken/coq/Induction.v|, another SF library that we have
    supplemented with solutions to relevant exercises.
    Nats are defined inductively using a unary representation
    (as Peano naturals).
    Most of the lemmas pertaining to nats are proven using
    the \verb+induction+ tactic.

    For our purposes, the set of natural numbers is most usefully
    structured as an ordered set, so we've verified (or made progress
    toawrd verifying) the order properties of the natural numbers
    as comparison methods, for example
    \verb`ble_nat` (\verb`<=` for nats).

  \item \textbf{Polymorphic lists.}
We will be sorting objects of the type \verb`list nat` (informally,
``natlists'') throughout this project.
Also, we will use lists of lists, \verb`list (list nat)` in Simsort.
Definitions of polymorphic lists are found in \verb`chicken/coq/Poly.v`
and \verb`chicken/coq/Lists.v`
other SF libraries modified as described above.
(The former defines polymorphic lists,
and the latter defines, specifically, lists of nats.)

  \item \textbf{Stack.}
    We're going to implement this using polymorphic lists.
    \todo{Methods will include\dots}

  \item \textbf{Heap.}
    \todo{Pseudocode here!}

\end{itemize}

\paragraph{Algorithms and proofs of them.}
\begin{itemize}
  \item \textbf{Fundamental methods and proofs relevant to all
                sorting algorithms.}
  \item \textbf{Mergesort.}
  \item \textbf{Insertion sort.}
  \item \textbf{Heap sort.}
  \item \textbf{Simsort.}
\end{itemize}


\section{Timeline}
\paragraph{Remainder of this week.}
\begin{itemize}
  \item
    foo
\end{itemize}

\paragraph{Week of April 20.}
\begin{itemize}
  \item
    foo
\end{itemize}

\todo{flesh this out}

\section{Progress}


\begin{thebibliography}{xx}
  \bibitem{cpdt}
    Chlipala, Adam. \emph{Certified Programming with Dependent Types}.

  \bibitem{sf}
    Pierce, Benjamin, et al. \emph{Software Foundations}.

%  \bibitem{filliatre1999certification}
%    Filliatre, Jean-Christophe and Magaud, Nicolas. \emph{Certification of
%    sorting algorithms in the system COQ}
%
%  \bibitem{deopenjdk}
%    de Gouw, Stijn and Rot, Jurriaan and de Boer, Frank S and Bubel, Richard
%    and Hahnle, Reiner. \emph{OpenJDK's java. utils. Collection. sort () is
%    broken: The good, the bad and the worst case}
\end{thebibliography}



\end{document}
